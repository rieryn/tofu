<!DOCTYPE html>
<html>
<body>


<body>
<canvas id="map" style = "position : absolute;"></canvas>
  <canvas id="objects" style = "position : absolute;"></canvas>
    <canvas id = "render" style = "position: absolute;"></canvas>

<p>test</p>
</body> 

<script>
//following tutorial from https://lodev.org/cgtutor/raycasting.html 
//modified to use js and canvas
//short summary:
//DDA is basically search along grid line intersections
//the wall is at the intersection
//then the wall height is calculated from the distance to the camera plane
//individual strips are rendered with drawImage
//sprites are sized, sorted by order, then if size<wall or if it's offscreen it's not shown
var mapX = 24;		
var mapY = 24;	
var screenX = 640;
var screenY =480;
var map =  document.getElementById('map');
var objects = document.getElementById("objects");
var render = document.getElementById("render");
map.width = screenX;
map.height = screenY;
objects.width = screenX;
objects.height = screenY;
render.width = screenX;
render.height = screenY;
var mapctx = map.getContext('2d');
var objctx = objects.getContext('2d');
var renderctx = render.getContext('2d');
var unit = screenY/mapY;
var gameMap = [
	  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
  [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
  [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
  [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
  [1,0,0,0,0,0,2,2,2,2,2,0,0,0,0,3,0,3,0,3,0,0,0,1],
  [1,0,0,0,0,0,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,1],
  [1,0,0,0,0,0,2,0,0,0,2,0,0,0,0,3,0,0,0,3,0,0,0,1],
  [1,0,0,0,0,0,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,1],
  [1,0,0,0,0,0,2,2,0,2,2,0,0,0,0,3,0,3,0,3,0,0,0,1],
  [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
  [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
  [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
  [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
  [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
  [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
  [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
  [1,4,4,4,4,4,4,4,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
  [1,4,0,4,0,0,0,0,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
  [1,4,0,0,0,0,5,0,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
  [1,4,0,4,0,0,0,0,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
  [1,4,0,4,4,4,4,4,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
  [1,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
  [1,4,4,4,4,4,4,4,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
];

var player = {
  //coordinate
  position:{
	x : 2,
	y : 2,
  },
  //vectors
  direction:{
    x: 1,
    y: 0,
  },
  plane:{
    x:1,
    y:1,
  },

	speed : 0,
	moveSpeed : 0.18,
  strafeSpeed:0,
	rotSpeed : 6 * Math.PI / 180
}
player.plane.x = rotateVector(player.direction.x, player.direction.y, -Math.PI/2).x * 120;
player.plane.y = rotateVector(player.direction.x, player.direction.y, -Math.PI/2).y * 120;
function drawMap() {
	for (var y=0; y < mapY; y++) {
		for (var x=0; x < mapX; x++) {
			var wall = gameMap[x][y];
			if (wall > 0) {
				mapctx.fillStyle = '#7fd5eb';
				mapctx.fillRect(
					x*unit,
					y*unit,
					unit,
					unit
				);
			}
		}
	}
}
function drawObj(){
  objctx.clearRect(0,0,screenX,screenY);
  objctx.fillStyle  = "black";
  objctx.fillRect(player.position.x*unit,
                  player.position.y*unit,
                  unit/5,unit/5);
  //direction visualization
  objctx.fillRect(
    player.position.x*unit+2*player.direction.x*unit,
    player.position.y*unit+player.direction.y*unit, 
    unit/5,unit/5);
  objctx.fillRect(
    4*unit,4*unit, 
    unit/5,unit/5);
  //0.01 is the rotationspeed and actually i still don't get it
  //camera plane visualization
  objctx.beginPath();
  objctx.moveTo(
    player.position.x*unit+0.01*player.plane.x*unit,
    player.position.y*unit+0.01*player.plane.y*unit);
  objctx.lineTo(
    player.position.x*unit-0.01*player.plane.x*unit,
    player.position.y*unit-0.01*player.plane.y*unit);
  objctx.stroke();
  //fov visuallization;
  objctx.beginPath();
  objctx.moveTo(
    player.position.x*unit,
    player.position.y*unit);
  objctx.lineTo(
    player.position.x*unit+player.direction.x*unit+0.01*player.plane.x*unit,
    player.position.y*unit+player.direction.y*unit+0.01*player.plane.y*unit);
  objctx.stroke();
  objctx.closePath();
  objctx.beginPath();
  objctx.moveTo(
    player.position.x*unit,
    player.position.y*unit);
  objctx.lineTo(
    player.position.x*unit+player.direction.x*unit-0.01*player.plane.x*unit,
    player.position.y*unit+player.direction.y*unit-0.01*player.plane.y*unit);
  objctx.stroke();

}

/*start Copyright (c) 2004-2020, Lode Vandevenne*/
function Raycast(){
  renderctx.clearRect(0,0,screenX,screenY);
  let ZBuffer=[];
  for(var x = 0; x < screenX; x++)
    {ZBuffer[x]=0;
      //calculate ray position and direction
      
      let dirX = player.direction.x;
      let dirY = player.direction.y;
      let planeX = player.plane.x*0.01;
      let planeY = player.plane.y*0.01;
      let cameraX = 2 * x / screenX - 1; //x-coordinate in camera space
      let rayDirX = dirX + planeX * cameraX;
      let rayDirY = dirY + planeY * cameraX;
      //deltaDistX = sqrt(1 + (rayDirY * rayDirY) / (rayDirX * rayDirX))
      // sqrt(rayDirX * rayDirX + rayDirY * rayDirY) simplifies to 1
      //
      //why is an exercise for the reader
      let deltaDistX = Math.abs(1 / rayDirX)
      let deltaDistY = Math.abs(1 / rayDirY)
      let blockX = Math.floor(player.position.x);
      let blockY = Math.floor(player.position.y);
      let posX = player.position.x;
      let posY = player.position.y;
      let sideDistX;
      let sideDistY;
      //wall height
      let perpWallDist;
      //ray step
      let stepX;
      let stepY;
      let hit = 0; //was there a wall hit?
      let side; //was a NS or a EW wall hit?
      
      
      //calculate step and initial sideDist
      if (rayDirX < 0)
      {
        stepX = -1;
        sideDistX = (player.position.x - blockX) * deltaDistX;
      }
      else
      {
        stepX = 1;
        sideDistX = (blockX + 1.0 - player.position.x) * deltaDistX;
      }
      if (rayDirY < 0)
      {
        stepY = -1;
        sideDistY = (player.position.y - blockY) * deltaDistY;
      }
      else
      {
        stepY = 1;
        sideDistY = (blockY + 1.0 - player.position.y) * deltaDistY;
      }
      while (hit == 0)
      {
        //jump to next map square, OR in x-direction, OR in y-direction
        if (sideDistX < sideDistY)
        {
          sideDistX += deltaDistX;
          blockX += stepX;
          side = 0;
        }
        else
        {
          sideDistY += deltaDistY;
          blockY += stepY;
          side = 1;
        }
        //Check if ray has hit a wall
        if (gameMap[blockX][blockY] > 0) hit = 1;
        //still don't know why this is faster than directly solving for intersections
        //Calculate distance projected on camera plane (Euclidean distance will give fisheye effect!) btw i still don't know what the camera plane is
       //end while loop
      } 
       let hh = screenY/2;
        if (side == 0) perpWallDist = (blockX - posX + (1 - stepX) / 2) / rayDirX;
        else perpWallDist = (blockY - posY + (1 - stepY) / 2) / rayDirY;
        let lineHeight = Math.round(hh / perpWallDist);
        let drawStart = -lineHeight / 2 + hh;
	      let drawEnd = drawStart + lineHeight;
        

        //x from 1-24
        renderctx.fillRect(x, drawStart, 10, lineHeight);
        ZBuffer[x] = perpWallDist;
    }
        castSprites(ZBuffer);
}
var sprites = [];
var myImage = new Image();
myImage.src = 'https://images-wixmp-ed30a86b8c4ca887773594c2.wixmp.com/f/c19ad38c-91d3-4e59-8600-391630fa8871/dd3dfb3-2043cbd7-637b-41a0-92f6-31978a1b4e03.png?token=eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJzdWIiOiJ1cm46YXBwOiIsImlzcyI6InVybjphcHA6Iiwib2JqIjpbW3sicGF0aCI6IlwvZlwvYzE5YWQzOGMtOTFkMy00ZTU5LTg2MDAtMzkxNjMwZmE4ODcxXC9kZDNkZmIzLTIwNDNjYmQ3LTYzN2ItNDFhMC05MmY2LTMxOTc4YTFiNGUwMy5wbmcifV1dLCJhdWQiOlsidXJuOnNlcnZpY2U6ZmlsZS5kb3dubG9hZCJdfQ.LqD6VKEJBF9t3rAZHpbZ55MtOzZK6zyJ-3jmJjAUnk0';
var testsprite = {
  img: myImage,
  y: 4,
  x: 4,
  height:200,
  width:100,
  
  
  
}
sprites.push(testsprite);
function castSprites(zBuffer){
    let h = screenY/2;
    let spriteOrder =[];
    let spriteDistance =[];
  for(let i = 0; i < sprites.length; i++)
    {
      spriteOrder[i] = i;
      spriteDistance[i] = ((player.position.x - sprites[i].x) * (player.position.x - sprites[i].x) + (player.position.y - sprites[i].y) * (player.position.y  - sprites[i].y)); //sqrt not taken, unneeded
    }
    //sortSprites(spriteOrder, spriteDistance, sprites.length);

    //after sorting the sprites, do the projection and draw them
    for(let i = 0; i < sprites.length; i++)
    {
      //translate sprite position to relative to camera
      let spriteX = sprites[spriteOrder[i]].x - player.position.x;
      let spriteY = sprites[spriteOrder[i]].y - player.position.y;

      //transform sprite with the inverse camera matrix
      // [ planeX   dirX ] -1                                       [ dirY      -dirX ]
      // [               ]       =  1/(planeX*dirY-dirX*planeY) *   [                 ]
      // [ planeY   dirY ]                                          [ -planeY  planeX ]

      let invDet = 1.0 / (player.plane.x*0.01 * player.direction.y - player.direction.x * player.plane.y*0.01); //required for correct matrix multiplication

      let transformX = invDet * ( player.direction.y * spriteX - player.direction.x * spriteY);
      let transformY = invDet * (-player.plane.y*0.01 * spriteX + player.plane.x*0.01 * spriteY); //this is actually the depth inside the screen, that what Z is in 3D

      let spriteScreenX = Math.floor((screenX / 2) * (1 + transformX / transformY));

      //calculate height of the sprite on screen
      let spriteHeight = Math.abs((h / (transformY))); //using 'transformY' instead of the real distance prevents fisheye
      //calculate lowest and highest pixel to fill in current stripe
      let drawStartY = -spriteHeight / 2 + h ;
      if(drawStartY < 0) drawStartY = 0;
      let drawEndY = spriteHeight/2 + h;
      if(drawEndY >= h) drawEndY = h - 1;

      //calculate width of the sprite
      let spriteWidth = Math.abs( screenY/2 / (transformY));
      let drawStartX = -spriteWidth + spriteScreenX;
      let drawEndX = spriteWidth + drawStartX;

      if(drawEndX >= screenX) drawEndX = screenX - 1;
      let scale = sprites[spriteOrder[i]].img.width /spriteWidth;
      let imgStart = drawStartX;
      let imgEnd = drawEndX;
      //loop through every vertical stripe of the sprite on screen
      if (drawStartX<0) drawStartX = 0;
      for(let stripe = drawStartX; stripe <= drawEndX; stripe++){

      if (transformY > zBuffer[Math.round(stripe)]) {
        					if (stripe - imgStart <= 1) { 
						imgStart = stripe;
					} else {
						imgEnd = stripe; 
						break;
					}
				}	
			}
      let imgWidth = imgEnd-imgStart;

        //the conditions in the if are:
        //1) it's in front of camera plane so you don't see things behind you
        //2) it's on the screen 
      var drawXStart = Math.round((imgStart - drawStartX) * scale);
				if (drawXStart < 0) {
					drawXStart = 0;
				}
        if(transformY > 0 && imgEnd>0 && imgStart< screenX &&imgWidth > 0){ 
            renderctx.drawImage(sprites[spriteOrder[i]].img, drawXStart, 0, imgWidth*scale, sprites[spriteOrder[i]].img.height, imgStart, drawStartY, imgWidth, spriteHeight);
          
        
      }
    }
}
/*end copyright block*/


drawMap();
drawObj();
function rotateVector (vx, vy, angle) {
    
    return  { x: vx * Math.cos(angle) - vy * Math.sin(angle),
              y: vx * Math.sin(angle) + vy * Math.cos(angle)
            }
}
function rotate(obj, angle) {
    let dir = rotateVector(obj.direction.x, obj.direction.y, angle);
    obj.direction.x = dir.x;
    obj.direction.y = dir.y;

    let plane = rotateVector(obj.plane.x, obj.plane.y, angle);
    obj.plane.x = plane.x;
    obj.plane.y = plane.y;
}
function update(){
 move();
    Raycast();

  drawObj();
  setTimeout(update,1000/30);
}
update();
function move() {
  let strafeSpeed = player.strafeSpeed * player.moveSpeed;
	let speed = player.speed * player.moveSpeed; 
  //calc direction vector
	var newX = player.position.x + player.direction.x*speed;
	var newY = player.position.y + player.direction.y*speed;
  newX += player.plane.x*strafeSpeed;
	newY += player.plane.y*strafeSpeed;
  //check for wall
  let parsedX = parseInt(newX);
  let parsedY = parseInt(newY);
  if((gameMap[parsedX][parsedY] == 0)){
	player.position.x = newX;
	player.position.y = newY;}
}
function bindKeys() {
	document.onkeydown = function(e) {
		e = e || window.event;
    
    switch (e.keyCode) {
			//up
			case 38, 87:
				player.speed = 1; break;
			//down
			case 40, 83:
				player.speed = -1; break;
			//left
			case 37, 65:
				player.strafeSpeed = -0.01; break;
			//right
			case 39, 68:
				player.strafeSpeed = 0.01; break;
      //Q strafe
      case 81:
        rotate(player,0.1); break;
      //E strafe
      case 69:
        rotate(player,-0.1); break;
		}
	}

	document.onkeyup = function(e) {
		e = e || window.event;
		switch (e.keyCode) {
			case 38, 87:
			case 40, 83:
				player.speed = 0; break;
			case 37, 65:
			case 39, 68:
				player.strafeSpeed = 0; break;
		}
	}
}
 bindKeys();












 </script>
</body>
</html>